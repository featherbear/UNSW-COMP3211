<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Pipelined Processors - COMP3211 Musings</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="z5206677"><meta name=description content="Pipelining involves performing several tasks at relatively the same time."><meta name=keywords content="featherbear,COMP3211,UNSW"><meta name=generator content="Hugo 0.68.3 with theme even"><link rel=canonical href=../../lectures/pipelined-processors/><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../manifest.json><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><link href=../../sass/main.min.46877d277c22ebe08dcb937692b8b1d6e40ef958752120243d0f48fdfabcb35a.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=../../css/typedjs.shortcode.css><link rel=stylesheet href=../../css/fixDetails.css><link rel=stylesheet href=../../css/fancyBox.css><meta property="og:title" content="Pipelined Processors"><meta property="og:description" content="Pipelining involves performing several tasks at relatively the same time."><meta property="og:type" content="article"><meta property="og:url" content="/lectures/pipelined-processors/"><meta property="article:published_time" content="2021-03-07T11:37:17+00:00"><meta property="article:modified_time" content="2021-11-02T12:26:48+11:00"><meta itemprop=name content="Pipelined Processors"><meta itemprop=description content="Pipelining involves performing several tasks at relatively the same time."><meta itemprop=datePublished content="2021-03-07T11:37:17+00:00"><meta itemprop=dateModified content="2021-11-02T12:26:48+11:00"><meta itemprop=wordCount content="1023"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Pipelined Processors"><meta name=twitter:description content="Pipelining involves performing several tasks at relatively the same time."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=../../ class=logo>COMP3211 Musings</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=../../><li class=mobile-menu-item>Home</li></a><a href=https://github.com/featherbear/UNSW-COMP3211><li class=mobile-menu-item>GitHub</li></a><a href=../../categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=../../ class=logo>COMP3211 Musings</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=../../>Home</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/featherbear/UNSW-COMP3211>GitHub</a></li><li class=menu-item><a class=menu-item-link href=../../categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Pipelined Processors</h1><div class=post-meta><span class=post-time>2021-03-07</span><div class=post-category><a href=../../categories/lectures/>Lectures</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#mips-pipelined-datapath>MIPS Pipelined Datapath</a><ul><li><a href=#stages>Stages</a></li><li><a href=#mips-design>MIPS Design</a></li></ul></li><li><a href=#partitioning>Partitioning</a></li><li><a href=#pipeline-registers>Pipeline Registers</a></li><li><a href=#pipeline-control>Pipeline Control</a></li><li><a href=#hazards>Hazards</a><ul><li><a href=#structural-hazard>Structural Hazard</a></li><li><a href=#data-hazard>Data Hazard</a></li><li><a href=#control-hazard>Control Hazard</a></li></ul></li><li><a href=#mitigating-hazards>Mitigating Hazards</a><ul><li><a href=#mitigating-structural-hazards>Mitigating Structural Hazards</a></li><li><a href=#mitigating-data-hazards>Mitigating Data Hazards</a></li></ul></li><li><a href=#static-predictions>Static Predictions</a><ul><li><a href=#pipeline-flush>Pipeline Flush</a></li></ul></li><li><a href=#dynamic-prediction>Dynamic Prediction</a><ul><li><a href=#1-bit-prediction-scheme>1-bit Prediction Scheme</a></li><li><a href=#2-bit-prediction-scheme>2-bit Prediction Scheme</a></li><li><a href=#n-bit-prediction-scheme><code>n</code>-bit Prediction Scheme</a></li><li><a href=#delay-branch>Delay Branch</a></li></ul></li></ul></nav></div></div><div class=post-content><p>Pipelining involves performing several tasks at relatively the same time.<br>Since a multi-cycle processor instruction has its tasks split into stages, previous stages of the current instruction can be used by other instructions; in order to speed up execution.</p><blockquote><p>i.e. a task uses stages A, B, C, D. When the task is on stage B, another task can use the resources in stage A</p></blockquote><p>Compared to the <a href=multi-cycle-processors>example in multicycle processors</a>, a pipelined design can execute the instructions in 8 clock cycles</p><hr><h1 id=mips-pipelined-datapath>MIPS Pipelined Datapath</h1><h2 id=stages>Stages</h2><ol><li>IF - <strong>I</strong>nstruction <strong>F</strong>etch from memory</li><li>ID - <strong>I</strong>nstruction <strong>D</strong>ecode and register read</li><li>EX - <strong>EX</strong>ecute operation or calculate address</li><li>MEM - access <strong>MEM</strong>ory operand</li><li>WB - <strong>W</strong>rite result <strong>B</strong>ack to register</li></ol><h2 id=mips-design>MIPS Design</h2><ul><li>All instructions are 32-bits - easy to fetch in one cycle</li><li>Few and regular instruction formats - can decode and read all in one step</li><li>Load/store addressing - Can calculate the address in the ALU at an early stage, allowing access in a later stage</li><li>Alignment of memory operands - allows memory access to take "one cycle"</li><li>Most resources are available</li></ul><p><img src=../../uploads/snipaste_2021-03-07_22-56-29.png alt></p><hr><h1 id=partitioning>Partitioning</h1><p>Partition the single cycle datapath into sections - each section forms a stage.</p><ul><li>Try to balance the stages for similar stage delays (reduce clock cycle time)</li><li>Try to make data flow in the same directions (avoid pipeline hazards)</li><li>Make sure the correct data is used for each instruction</li></ul><p><img src=../../uploads/snipaste_2021-03-07_23-48-45.png alt></p><ul><li>Shaded|Unshaded - Write into</li><li>Unshaded|Shaded - Read from</li></ul><p>Find the shaded part of the component, that's the data direction</p><h1 id=pipeline-registers>Pipeline Registers</h1><p>To retain the values of an instruction to be used in other stages, the values are saved in <strong>pipeline registers</strong>. They are named by combining the two stages using that register.</p><p>e.g. IF/ID register</p><p>Each logical component (i.e. instruction memory, register read ports can only be used in a single pipeline stage.</p><hr><h1 id=pipeline-control>Pipeline Control</h1><p>Pipeline processes need to be controlled</p><ul><li>Label control points</li><li>Determine control settings</li><li>Design control logic</li></ul><p><img src=../../uploads/snipaste_2021-03-08_02-16-29.png alt></p><hr><p><img src=../../uploads/snipaste_2021-03-08_02-18-58.png alt></p><p><img src=../../uploads/snipaste_2021-03-08_02-30-23.png alt></p><p><img src=../../uploads/snipaste_2021-03-08_02-57-09.png alt></p><hr><h1 id=hazards>Hazards</h1><p>Situations where the instruction execution cannot proceed in the pipeline</p><h2 id=structural-hazard>Structural Hazard</h2><blockquote><p>The required resource is busy</p></blockquote><p><img src=../../uploads/snipaste_2021-03-08_03-01-34.png alt></p><h2 id=data-hazard>Data Hazard</h2><blockquote><p>Need to wait for the previous instruction to update its data</p></blockquote><p><img src=../../uploads/snipaste_2021-03-08_03-02-25.png alt></p><h3 id=data-dependency-types>Data Dependency types</h3><ul><li>RAR - Read after Read</li><li>WAW - Write after Write</li><li>WAR - Write after Read</li><li>RAW - Read after Write</li></ul><h2 id=control-hazard>Control Hazard</h2><blockquote><p>The control decision cannot be made until the condition check by the previous instruction is completed</p></blockquote><p><img src=../../uploads/snipaste_2021-03-08_03-04-57.png alt></p><h1 id=mitigating-hazards>Mitigating Hazards</h1><h2 id=mitigating-structural-hazards>Mitigating Structural Hazards</h2><blockquote><p>Never access a resource more than once per cycle</p></blockquote><ul><li>Allocate each resource to a single pipeline stage<ul><li>Duplicate resources if necessary (<em>e.g. IMEM, DMEM</em>)</li></ul></li><li>Every instruction must follow the same sequence of cycles/stages<ul><li><em>Skipping a stage can introduce structural hazards</em></li><li>However, some trailing cycles/stages can be dropped<ul><li>i.e. <code>BRA</code> / <code>JMP</code> - don't need WB or MEM</li></ul></li></ul></li></ul><p><img src=../../uploads/snipaste_2021-03-08_03-19-19.png alt><br>In an ideal case, CPI = 1 (given a constant stream of instructions, each cycle a new instruction starts, but another instruction finishes)</p><p>In a one-memory case, the CPI increases to 1.2 as DM and IM stages can't occur concurrently</p><h2 id=mitigating-data-hazards>Mitigating Data Hazards</h2><blockquote><p>Properly schedule / partition tasks in the pipeline</p></blockquote><p>To detect data hazards, we check for data dependencies between instructions and its preceding instructions</p><ul><li>Eliminate WAR (write after read) by always fetching operands early in the pipeline<ul><li>ID stage</li></ul></li><li>Eliminate WAW (write after write) by doing all WBs in order<ul><li>Single stage for writing</li></ul></li></ul><blockquote><p>Mitigating RAW (read after write)</p></blockquote><p><img src=../../uploads/snipaste_2021-03-08_03-44-21.png alt></p><p>If instructions depend on the result of a previous instruction, we need to delay that instruction from occurring...</p><h3 id=stalling---stall-the-instruction-execution>Stalling - stall the instruction execution</h3><p>Load Use Hazard (LUH) - When a load instruction is followed by an instruction dependent on the memory data (i.e. "not yet")</p><p>Prevent PC and IF/ID registers from changing</p><p>Set the EX, MEM and WB control fields of the ID/EX register to 0 to perform a <code>no-op</code></p><p>This is performed by a Hazard Detection Unit, which reads the states of the different pipeline registers, and controls the writeability of the IF/ID register</p><p><img src=../../uploads/snipaste_2021-03-08_04-27-01.png alt></p><h3 id=forwarding---if-the-correct-data-is-available-forward-the-data-to-where-it-is-required>Forwarding - if the correct data is available, forward the data to where it is required</h3><p>Update a pipeline register to contain the correct value, so that it can be used</p><hr><p><img src=../../uploads/snipaste_2021-03-19_01-21-54.png alt></p><p><img src=../../uploads/snipaste_2021-03-08_04-18-12.png alt></p><h3 id=stall-and-forward>Stall AND Forward</h3><p>Ooooh smart!</p><hr><h1 id=static-predictions>Static Predictions</h1><p>Predicts that all branch instructions have the same behaviour - either never, or always taken</p><ul><li>When the prediction (never taken[?]) is correct, the pipeline continues processing</li><li>When the prediction is wrong, the instruction(s?) after the branch instruction are discarded</li></ul><blockquote><p>Load each instruction every clock cycle, but discard the latter instructions if a branch occurs</p></blockquote><h2 id=pipeline-flush>Pipeline Flush</h2><p><img src=../../uploads/screenshot-from-2021-03-13-15-45-25.png alt></p><p>If the prediction is wrong, 3 instructions may need to be flushed. (Can be improved!)</p><p>To mitigate the performance penalty from flushing, there are several improvement methods.</p><ul><li>Make the decision for branching earlier<ul><li>Calculate the target address in the ID stage</li><li>Compare register contents in the ID stage (using bitwise XOR)</li><li>Require forwarding to ID stage and hazard detection<ul><li>(Only if the branch is dependent upon the result of an R-type or LOAD instruction that is still in the pipeline)</li></ul></li></ul></li><li>Flush only one instruction<ul><li><code>IF.Flush</code> control signal sets the instruction field of the IF/ID register to 0</li></ul></li></ul><p><img src=../../uploads/screenshot-from-2021-03-13-15-52-18.png alt></p><hr><p><img src=../../uploads/screenshot-from-2021-03-13-15-40-29.png alt><br>4N / (xN * 1 + (1-x)N * 4)<br>4/(4-3x)</p><h1 id=dynamic-prediction>Dynamic Prediction</h1><p>Prediction is made on the fly, depending on the history of the branch behaviour.<br>This history is stored in a <strong>branch history table</strong> / <strong>branch prediction table.</strong></p><p><img src=../../uploads/snipaste_2021-03-15_01-37-12.png alt></p><h2 id=1-bit-prediction-scheme>1-bit Prediction Scheme</h2><blockquote><p>The history bit (1-bit wide), contains the result of the branch - either taken or not taken</p></blockquote><p>Simple, however it has limited prediction accuracy.<br>i.e in a loop, the final case will exit the loop. If that loop is re-executed, the exit check history will be incorrect for the future iterations</p><ul><li>T -> T</li><li>N -> N</li></ul><h2 id=2-bit-prediction-scheme>2-bit Prediction Scheme</h2><blockquote><p>The history bit is now 2 bits wide. A prediction must be wrong twice before it is changed</p></blockquote><p><img src=../../uploads/snipaste_2021-03-15_01-44-16.png alt></p><ul><li>TT -> T</li><li>NN -></li><li>TN -> T</li><li>NT -> N</li></ul><p><img src=../../uploads/snipaste_2021-03-15_01-48-13.png alt></p><h2 id=n-bit-prediction-scheme><code>n</code>-bit Prediction Scheme</h2><ul><li>Frequency based - (majority -> prediction) - no correlations are taken into account</li><li>Pattern based (more accurate and efficient)<ul><li>Branch history shift buffer - correlation oriented</li><li>Pattern prediction history table - frequency oriented</li></ul></li></ul><h2 id=delay-branch>Delay Branch</h2><p>A compiler-oriented approach that will always execute the instruction after the branch</p><p><img src=../../uploads/snipaste_2021-03-15_02-31-03.png alt></p><hr><p><img src=../../uploads/snipaste_2021-03-15_02-34-07.png alt><br><img src=../../uploads/snipaste_2021-03-15_02-34-37.png alt><br><img src=../../uploads/snipaste_2021-03-15_02-34-55.png alt><br><img src=../../uploads/snipaste_2021-03-15_02-35-23.png alt></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=../../lectures/multi-cycle-processors/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Multi Cycle Processors</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=../../lectures/introduction-to-memory/><span class="next-text nav-default">Introduction to Memory</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article><script>(function(f,a,t,h,o,m){a[h]=a[h]||function(){(a[h].q=a[h].q||[]).push(arguments)};o=f.createElement('script'),m=f.getElementsByTagName('script')[0];o.async=1;o.src=t;o.id='fathom-script';m.parentNode.insertBefore(o,m)})(document,window,'//ss.featherbear.cc/tracker.js','fathom');fathom('set','siteId','NEQTU');fathom('trackPageview');</script></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:z5206677@student.unsw.edu.au class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/andrewjinmengwong/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/featherbear class="iconfont icon-github" title=github></a><a href=https://www.instagram.com/_andrewjwong/ class="iconfont icon-instagram" title=instagram></a><a href=../../index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2021
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Andrew Wong (z5206677)</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=../../js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-107434487-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=../../js/typed.js@2.0.9></script><script src=../../js/typedjs.shortcode.js></script></body></html>